




<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    



 <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> 

    <!-- <link rel="stylesheet" href="/assets/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous"> -->
    <link rel="stylesheet" href="../../../assets/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../assets/open-iconic-bootstrap.min.css" crossorigin="anonymous">
    <link href='../../../assets/fontawesome/css/all.css' rel='stylesheet'>
    <link rel="stylesheet" href="../../../assets/open-sans.css" crossorigin="anonymous">
    <!-- <link rel="stylesheet" href="/assets/theme/main.css" crossorigin="anonymous" id="theme"> -->
    <link rel="stylesheet" href="../../../assets/theme/main.css" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../assets/theme/main_dark.css" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../assets/theme/switch.css" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../assets/syntax.css" crossorigin="anonymous">
    <link rel="shortcut icon" type="image/png" href="../../../assets/favicon.png">
    <link href="../../../assets/open-iconic-bootstrap.min.css" rel="stylesheet">
    <link href="../../../assets/bootstrap-toc.min.css" rel="stylesheet">
    <link href="../../../assets/fullcalendar.min.css" rel="stylesheet">
    <link href="../../../assets/jquery-ui.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <!-- <link href="/assets/fullcalendar/packages/core/main.min.css" rel="stylesheet"> -->
    <link href="../../../assets/fullcalendar/packages/daygrid/main.min.css" rel="stylesheet">
    <link href="../../../assets/fullcalendar/packages/timegrid/main.min.css" rel="stylesheet">
    <link href="../../../assets/fullcalendar/packages/list/main.min.css" rel="stylesheet">
    <link href="../../../assets/fullcalendar/packages/bootstrap/main.min.css" rel="stylesheet">

    <title> CS 61C </title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-154217821-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-154217821-1');
    </script>
    
    <script>
    var loc = window.location.href + '';
    if (loc.indexOf('http://') == 0 && !["localhost", "127.0.0.1"].includes(window.location.hostname)){
        window.location.href = loc.replace('http://','https://');
    }
    var baseurl = "";
    </script>

  </head>
  <body>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="../../../assets/jquery.min.js" crossorigin="anonymous"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script> -->
    <script src="../../../assets/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <script src="../../../assets/bootstrap-toc.min.js"></script>
    <script src="../../../assets/moment.min.js"></script>
    <script src="../../../assets/fullcalendar.min.js"></script>
    <script src="../../../assets/fullcalendar-gcal.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/core/main.min.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/daygrid/main.min.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/timegrid/main.min.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/list/main.min.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/google_calendar/main.min.js"></script>
    <script type="text/javascript" src="../../../assets/fullcalendar/packages/bootstrap/main.min.js"></script>
    <!-- <script type="text/javascript" src="/assets/fullcalendar/packages/moment/main.js"></script>
    <script type="text/javascript" src="/assets/fullcalendar/packages/moment-timezone/main.js"></script> -->



    <div class="wrapper bg-white">
        <nav class="navbar bg-dark navbar-dark navbar-expand-md align-items-center">
            <div class="container">
                <a class="navbar-brand brand-berkeley" href="https://cs61c.org/su20">
                  <img src = "../../../assets/icon-small.png" class="img-fluid" /> CS 61C
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon"></span>
                </button>
            
                <div class="collapse navbar-collapse justify-content-end" id="navbarSupportedContent">
                  <ul class="navbar-nav">
                      
                      
                        


    <li class="nav-item ">
    <a class="nav-link "
         href="../../calendar.html" >
        Calendar
        
    </a>
    </li>


                      
                        


    <li class="nav-item ">
    <a class="nav-link "
         href="../../staff.html" >
        Staff
        
    </a>
    </li>


                      
                        


    <li class="nav-item ">
    <a class="nav-link "
         href="../../policies.html" >
        Policies
        
    </a>
    </li>


                      
                        


    <li class="nav-item ">
    <a class="nav-link  text-muted "
         target = "_blank" href="https://piazza.com/" >
        Piazza
        
        <span class="oi oi-external-link"></span> 
        
    </a>
    </li>


                      
                      
                        


    <li class="nav-item ">
    <a class="nav-link  text-muted "
         target = "_blank" href="https://venus.cs61c.org/" >
        Venus
        
        <span class="oi oi-external-link"></span> 
        
    </a>
    </li>


                      
                        


    <li class="nav-item ">
    <a class="nav-link "
         href="https://cs61c.org/resources/" >
        Resources
        
    </a>
    </li>


                      
                        


    <li class="nav-item ">
    <a class="nav-link "
         href="https://cs61c.org/?redirect=false" >
        Semesters
        
    </a>
    </li>


                      

                      <li class="nav-item" align="center">
                        <label class="switch">
                        <input type="checkbox" id="themeSwitch" onload="if (returnThemeBasedOnLocalStorage() === 'dark') {this.clicked = true;}" onclick="enableTheme(this.checked === false ? 'light' : 'dark', true);">
                          <span class="slider round"></span>
                        </label>
                        <br>
                        <label for="themeSwitch" id="switch_text">Dark Mode</label>
                      </li>
                  </ul>
                </div>
            </div>
          </nav>
      
          <div class="container">
              <h1 class="mb-4">Project 3&#58; CS61CPU</h1>


    <div class="row">
        <div class="col-sm-9">
            <style>
.container .row img {
  max-width: 100%;
}
</style>

<p><img src="creation_of_nandam_su20.jpg" alt="NAND gates everywhere!" /></p>

<h2 id="overview">Overview</h2>

<p><strong>Part A Deadline: Friday, July 17, 2020</strong></p>

<p><strong>Part B Deadline: Friday, July 24, 2020</strong></p>

<p>So you’ve (hopefully) dealt with CS61Classify. But, you might be wondering, how exactly do all those <code class="language-plaintext highlighter-rouge">sw ra, 40(sp)</code> instructions get executed? What’s inside that mystery chip in your computer called the “CPU”? Welcome to Project 3!</p>

<p>In Part A (Tasks 1-3), you’ll be wiring up the ALU and RegFile for a basic RISC-V CPU, as well as implementing the CPU datapath for executing <code class="language-plaintext highlighter-rouge">addi</code> instructions. In Part B (Tasks 4-5), you’ll use these components (and others) to wire up a working CPU that runs actual RISC-V instructions!</p>

<hr />

<h2 id="tips-and-guidelines">Tips and Guidelines</h2>

<ul>
  <li>Do not use the version of Logisim preinstalled on the Soda lab computers, as this will mess up your circuits! Use the <code class="language-plaintext highlighter-rouge">logisim-evolution.jar</code> provided in your project repository.</li>
  <li>You are allowed to use any of Logisim’s built-in blocks for all parts of this project.</li>
  <li>Save frequently and commit frequently! Try to save your code in Logisim every 5 minutes or so, and commit every time you produce a new feature, even if it is small.</li>
  <li>Sanity tests for most project tasks are included with the project starter code. More information is available under the Testing section of each task.</li>
  <li>See https://piazza.com/class/k755fag7yx2498?cid=891 for a custom tests and debugging walkthrough video</li>
  <li>Do not move the input and output pins in your circuit, since this could knock the pins out of alignment (in other words, autograder tests will fail)! Check the harness circuits, as well as <code class="language-plaintext highlighter-rouge">cpu.circ</code>, to make sure your circuits fit in the testing harnesses.</li>
  <li>You may make new subcircuits, but they must be located in the files given in the starter code. You may not make new <code class="language-plaintext highlighter-rouge">.circ</code> files; the autograder will fail you if you do this!</li>
  <li><code class="language-plaintext highlighter-rouge">.circ</code> files use the XML format, which makes it hard for Git to automerge. We recommend working on a single computer at a time; if you use multiple computers, make sure that you have pushed and pulled your code before switching devices.</li>
  <li>We recommend completing Lab 05 and Lab 06 before starting on this project. Both labs cover many Logisim basics that will be useful for this project.</li>
  <li>Some common sources of Logisim errors, for your debugging convenience:</li>
</ul>

<h2><img src="error_wire_2.png" alt="alt-text" /></h2>

<h2 id="part-a-getting-started">Part A: Getting Started</h2>

<p>For this project, the computer you’re working on needs be able to run Java and Python 3, which you should have set up in Project 2. This project specification will use <code class="language-plaintext highlighter-rouge">python3</code> for sample commands; depending on your system, you may need to use <code class="language-plaintext highlighter-rouge">python</code> or <code class="language-plaintext highlighter-rouge">py</code> instead. We will be using Logisim Evolution, a Java-based GUI program, so we strongly recommend working on a laptop or desktop with Java installed and <strong>a monitor directly attached</strong>. Using window forwarding over a Hive SSH session is discouraged, and may lead to instability and general headaches.</p>

<p>Please follow the directions in this Google Form to get a repository: <a href="https://forms.gle/ruhhX4e5ojozzNg48">https://forms.gle/ruhhX4e5ojozzNg48</a>. After completing the form, clone your GitHub Classroom repository and add the starter code repository as a remote:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone YOUR_REPO_URL
<span class="nv">$ </span><span class="nb">cd </span>YOUR_REPO_NAME
<span class="nv">$ </span>git remote add starter https://github.com/61c-teach/su20-proj3-starter.git
<span class="nv">$ </span>git pull starter master
</code></pre></div></div>

<p>If we make changes to the starter code, you can update your repository with <code class="language-plaintext highlighter-rouge">git pull starter master</code>.</p>

<hr />

<h2 id="task-1-arithmetic-logic-unit-alu">Task 1: Arithmetic Logic Unit (ALU)</h2>

<p>Your first task is to create an ALU that supports all the operations needed by the instructions in our ISA (which is described in further detail in the next section). Please note that we treat overflow as RISC-V does with unsigned instructions, meaning that we ignore overflow.</p>

<p>We have provided a skeleton of an ALU for you in <code class="language-plaintext highlighter-rouge">alu.circ</code>. It has three
inputs:</p>

<table>
  <thead>
    <tr>
      <th>Input Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>32</td>
      <td style="text-align: left">Data to use for Input A in the ALU operation</td>
    </tr>
    <tr>
      <td>B</td>
      <td>32</td>
      <td style="text-align: left">Data to use for Input B in the ALU operation</td>
    </tr>
    <tr>
      <td>ALUSel</td>
      <td>4</td>
      <td style="text-align: left">Selects which operation the ALU should perform (see the list of operations with corresponding switch values below)</td>
    </tr>
  </tbody>
</table>

<p>… and one output:</p>

<table>
  <thead>
    <tr>
      <th>Output Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Result</td>
      <td>32</td>
      <td style="text-align: left">Result of the ALU operation</td>
    </tr>
  </tbody>
</table>

<p>Below is the list of ALU operations for you to implement, along with their associated ALUSel values. All of them are required with the exception of <code class="language-plaintext highlighter-rouge">mulh</code>, which will take some extra effort to implement (but you’re certainly up to the task!). You are allowed and encouraged to use built-in Logisim blocks to implement the arithmetic operations.</p>

<table>
  <thead>
    <tr>
      <th>Switch Value</th>
      <th style="text-align: left">Instruction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td style="text-align: left">add: <code class="language-plaintext highlighter-rouge">Result = A + B</code></td>
    </tr>
    <tr>
      <td>1</td>
      <td style="text-align: left">and: <code class="language-plaintext highlighter-rouge">Result = A &amp; B</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: left">or: <code class="language-plaintext highlighter-rouge">Result = A | B</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: left">xor: <code class="language-plaintext highlighter-rouge">Result = A ^ B</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td style="text-align: left">srl: <code class="language-plaintext highlighter-rouge">Result = (unsigned) A &gt;&gt; B</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td style="text-align: left">sra: <code class="language-plaintext highlighter-rouge">Result = (signed) A &gt;&gt; B</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td style="text-align: left">sll: <code class="language-plaintext highlighter-rouge">Result = A &lt;&lt; B</code></td>
    </tr>
    <tr>
      <td>7</td>
      <td style="text-align: left">slt: <code class="language-plaintext highlighter-rouge">Result = (A &lt; B (signed)) ? 1 : 0</code></td>
    </tr>
    <tr>
      <td>8</td>
      <td style="text-align: left">divu: <code class="language-plaintext highlighter-rouge">Result = (unsigned) A / B</code></td>
    </tr>
    <tr>
      <td>9</td>
      <td style="text-align: left">remu: <code class="language-plaintext highlighter-rouge">Result = (unsigned) A % B</code></td>
    </tr>
    <tr>
      <td>10</td>
      <td style="text-align: left">mul: <code class="language-plaintext highlighter-rouge">Result = (signed) (A * B)[31:0]</code></td>
    </tr>
    <tr>
      <td>11</td>
      <td style="text-align: left">mulhu: <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
    </tr>
    <tr>
      <td>12</td>
      <td style="text-align: left">sub: <code class="language-plaintext highlighter-rouge">Result = A - B</code></td>
    </tr>
    <tr>
      <td>13</td>
      <td style="text-align: left">bsel: <code class="language-plaintext highlighter-rouge">Result = B</code></td>
    </tr>
    <tr>
      <td>14</td>
      <td style="text-align: left">mulh: <code class="language-plaintext highlighter-rouge">Result = (signed) (A * B)[63:32]</code></td>
    </tr>
  </tbody>
</table>

<p>When implementing <code class="language-plaintext highlighter-rouge">mul</code> and <code class="language-plaintext highlighter-rouge">mulh</code>, notice that the multiply block has a “Carry Out” output (the adder block also has this, but you will not need this). Experiment a bit with it, and see what you get for both the result and carryout with negative and positive 2’s complement numbers. You should realize why we made <code class="language-plaintext highlighter-rouge">mulh</code> extra credit.</p>

<p>You can make any modifications to <code class="language-plaintext highlighter-rouge">alu.circ</code> you want, but the outputs <strong>must</strong> obey the behavior specified above. If you create additional subcircuits, they must also be in <code class="language-plaintext highlighter-rouge">alu.circ</code> (you may not make new <code class="language-plaintext highlighter-rouge">.circ</code> files). Additionally, your ALU <strong>must</strong> be able to fit in the provided harness <code class="language-plaintext highlighter-rouge">alu_harness.circ</code>. This means that you should take care not to move inputs or outputs. To verify that changes you made didn’t break anything, you can open <code class="language-plaintext highlighter-rouge">alu_harness.circ</code> and ensure there are no errors and that the circuit functions well.</p>

<p><strong>Hints:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">add</code> is already made for you; feel free to use a similar structure when implementing your other blocks.</li>
  <li>You can hover your cursor over an input/output on a block to get more detailed information about that input/output.</li>
  <li>If you want to know more details about each block, go to Help-&gt;Library Reference for more information on the block and its inputs and outputs.</li>
  <li>You might find bit splitters or extenders useful when implementing <code class="language-plaintext highlighter-rouge">sra</code> and <code class="language-plaintext highlighter-rouge">srl</code>.</li>
  <li>Use tunnels! They will make your wiring cleaner and easier to follow, and will reduce your chances of encountering crossed wires or unexpected errors.</li>
  <li>A multiplexer (MUX) might be useful when deciding which block output you want to ouput. In other words, consider simply processing the input in all blocks, and then outputing the one of your choice.</li>
</ul>

<hr />

<h3 id="alu-testing">ALU Testing</h3>

<p>We’ve provided a group of ALU sanity tests in the <code class="language-plaintext highlighter-rouge">tests/part_a/alu</code> directory. Running the test runner for this group will run the ALU tests and produce output in the <code class="language-plaintext highlighter-rouge">tests/part_a/alu/student_output</code> directory.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a alu
</code></pre></div></div>

<p>We’ve also provided <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code>, which can interpret this output in a readable format for you. To use it, do the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE
</code></pre></div></div>

<p>For example, to see <code class="language-plaintext highlighter-rouge">reference_output/alu-add-ref.out</code> in readable format, you would do this:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out
</code></pre></div></div>

<p>If you want to see the difference between your output and the reference solution, put the readable outputs into new <code class="language-plaintext highlighter-rouge">.out</code> files and <code class="language-plaintext highlighter-rouge">diff</code> them. For example, for the <code class="language-plaintext highlighter-rouge">alu-add</code> test, you would do:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out <span class="o">&gt;</span> reference.out
<span class="nv">$ </span>python3 binary_to_hex_alu.py student_output/alu-add-student.out <span class="o">&gt;</span> student.out
<span class="nv">$ </span>diff reference.out student.out
</code></pre></div></div>

<hr />

<h2 id="task-2-register-file-regfile">Task 2: Register File (RegFile)</h2>

<p>As you learned in class, RISC-V architecture has 32 registers. However, in this project, <strong>you will only implement 9 of them (specified below)</strong> to save you some repetitive work. This means your rs1, rs2, and rd signals will still be 5-bit, but we will only test you on the specified registers.</p>

<p>Your RegFile should be able to write to or read from these registers specified in a given RISC-V instruction without affecting any other registers. There is one notable exception: your RegFile should NOT write to x0, even if an instruction tries. Remember that the zero register should ALWAYS have the value 0x0. You should NOT gate the clock at any point in your RegFile: the clock signal should ALWAYS connect directly to the clock input of the registers without passing through ANY combinational logic.</p>

<p>The registers and their corresponding numbers are listed below.</p>

<table>
  <thead>
    <tr>
      <th>Register Number</th>
      <th>Register Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x0</td>
      <td>x0</td>
    </tr>
    <tr>
      <td>x1</td>
      <td>ra</td>
    </tr>
    <tr>
      <td>x2</td>
      <td>sp</td>
    </tr>
    <tr>
      <td>x5</td>
      <td>t0</td>
    </tr>
    <tr>
      <td>x6</td>
      <td>t1</td>
    </tr>
    <tr>
      <td>x7</td>
      <td>t2</td>
    </tr>
    <tr>
      <td>x8</td>
      <td>s0</td>
    </tr>
    <tr>
      <td>x9</td>
      <td>s1</td>
    </tr>
    <tr>
      <td>x10</td>
      <td>a0</td>
    </tr>
  </tbody>
</table>

<p>You are provided with the skeleton of a register file in <code class="language-plaintext highlighter-rouge">regfile.circ</code>. The register file circuit has six inputs:</p>

<table>
  <thead>
    <tr>
      <th>Input Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Clock</td>
      <td>1</td>
      <td style="text-align: left">Input providing the clock. This signal can be sent into subcircuits or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not “and” it with anything, etc.).</td>
    </tr>
    <tr>
      <td>RegWEn</td>
      <td>1</td>
      <td style="text-align: left">Determines whether data is written to the register file on the next rising edge of the clock.</td>
    </tr>
    <tr>
      <td>Read Register 1 (rs1)</td>
      <td>5</td>
      <td style="text-align: left">Determines which register’s value is sent to the Read Data 1 output, see below.</td>
    </tr>
    <tr>
      <td>Read Register 2 (rs2)</td>
      <td>5</td>
      <td style="text-align: left">Determines which register’s value is sent to the Read Data 2 output, see below.</td>
    </tr>
    <tr>
      <td>Write Register (rd)</td>
      <td>5</td>
      <td style="text-align: left">Determines which register to set to the value of Write Data on the next rising edge of the clock, assuming that RegWEn is a 1.</td>
    </tr>
    <tr>
      <td>Write Data (wb)</td>
      <td>32</td>
      <td style="text-align: left">Determines what data to write to the register identified by the Write Register input on the next rising edge of the clock, assuming that RegWEn is 1.</td>
    </tr>
  </tbody>
</table>

<p>The register file also has the following outputs:</p>

<table>
  <thead>
    <tr>
      <th>Output Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rs1</td>
      <td>32</td>
      <td style="text-align: left">Driven with the value of the register identified by the Read Register 1 input.</td>
    </tr>
    <tr>
      <td>rs2</td>
      <td>32</td>
      <td style="text-align: left">Driven with the value of the register identified by the Read Register 2 input.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ra</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">ra</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sp</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">sp</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">t0</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">t0</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">t1</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">t1</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">t2</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">t2</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">s0</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">s0</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">s1</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">s1</code> (This is a DEBUG/TEST output.)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">a0</code> Value</td>
      <td>32</td>
      <td style="text-align: left">Always driven with the value of <code class="language-plaintext highlighter-rouge">a0</code> (This is a DEBUG/TEST output.)</td>
    </tr>
  </tbody>
</table>

<p>The test outputs at the top of your <code class="language-plaintext highlighter-rouge">regfile.circ</code> file are present for testing and debugging purposes. If you were implementing a real register file, you would omit those outputs. In our case, be sure they are included correctly–if they are not, you will not pass.</p>

<p>You can make any modifications to <code class="language-plaintext highlighter-rouge">regfile.circ</code> you want, but the outputs must obey the behavior specified above. If you create additional subcircuits, they must also be in <code class="language-plaintext highlighter-rouge">regfile.circ</code> (you may not make new <code class="language-plaintext highlighter-rouge">.circ</code> files). In addition, your <code class="language-plaintext highlighter-rouge">regfile.circ</code> that you submit <strong>must</strong> fit into the <code class="language-plaintext highlighter-rouge">regfile_harness.circ</code> file we have provided for you. This means that you should take care not to move inputs or outputs. To verify changes you have made didn’t break anything, you can open <code class="language-plaintext highlighter-rouge">regfile_harness.circ</code> and ensure there are no errors and that the circuit functions well.</p>

<p><strong>Hints:</strong></p>
<ul>
  <li>Take advantage of copy-paste! It might be a good idea to make one register completely and use it as a template for the others to avoid repetitive work.</li>
  <li>I would advise you not to use the enable input on your MUXes. In fact, you can turn that feature off. I would also advise you to also turn “three-state?” to off. Take a look at all the inputs to a logisim register and see what they all do.</li>
  <li>Again, MUXes are your friend, but also DeMUXes.</li>
  <li>Think about what happens in the register file after a single instruction is executed. Which values change? Which values stay the same? Registers are clock-triggered–what does that mean?</li>
  <li>Keep in mind registers have an “enable” input available, as well as a clock input.</li>
  <li>What is the value of <code class="language-plaintext highlighter-rouge">x0</code>?</li>
</ul>

<hr />

<h3 id="regfile-testing">RegFile Testing</h3>

<p>We’ve provided a group of RegFile sanity tests in the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile</code> directory. Running the test runner for this group will run the ALU tests and produce output in the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile/student_output</code> directory.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a regfile
</code></pre></div></div>

<p>We’ve also provided <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code>, which works like <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> from Task 1.</p>

<hr />

<h2 id="task-3-the-addi-instruction">Task 3: The <code class="language-plaintext highlighter-rouge">addi</code> Instruction</h2>

<p>As your final task for Part A, you’re going to implement a CPU that’s capable of executing one instruction: <code class="language-plaintext highlighter-rouge">addi</code>! You’re welcome to implement other instructions at this time, but you’ll only be graded on whether or not <code class="language-plaintext highlighter-rouge">addi</code> executes correctly for Part A. When we release Part B, there will be more detailed instructions on how to implement the other instructions.</p>

<h3 id="info-memory">Info: Memory</h3>

<p>The Memory unit (located in <code class="language-plaintext highlighter-rouge">mem.circ</code>) is already fully implemented for you! However, the <code class="language-plaintext highlighter-rouge">addi</code> instruction does NOT use the Memory unit, so you can leave it untouched for Part A.</p>

<p>If you are interested, here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WriteAdd</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Address to read/write to in Memory</td>
    </tr>
    <tr>
      <td>WriteData</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value to be written to Memory</td>
    </tr>
    <tr>
      <td>MemRW</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Equal to one on any instructions that write to Memory and zero otherwise</td>
    </tr>
    <tr>
      <td>CLK</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Driven by the clock input to the CPU</td>
    </tr>
    <tr>
      <td>ReadData</td>
      <td>Output</td>
      <td>32</td>
      <td style="text-align: left">Value of the data stored at the specified address</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-branch-comparator">Info: Branch Comparator</h3>

<p>The Branch Comparator unit (located in <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>) provided in the skeleton is unimplemented, but the <code class="language-plaintext highlighter-rouge">addi</code> instruction does NOT use the Branch Comparator unit, so you don’t have to worry about it for Part A.</p>

<p>If you are interested, here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rs1</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value in the first register to be compared</td>
    </tr>
    <tr>
      <td>rs2</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value in the second register to be compared</td>
    </tr>
    <tr>
      <td>BrUn</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted</td>
    </tr>
    <tr>
      <td>BrEq</td>
      <td>Output</td>
      <td>1</td>
      <td style="text-align: left">Equal to one if the two values are equal</td>
    </tr>
    <tr>
      <td>BrLt</td>
      <td>Output</td>
      <td>1</td>
      <td style="text-align: left">Equal to one if the value in rs1 is less than the value in rs2</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-immediate-generator">Info: Immediate Generator</h3>

<p>The Immediate Generator (“Imm Gen”) unit (located in <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) provided in the skeleton is unimplemented. The <code class="language-plaintext highlighter-rouge">addi</code> instruction requires an immediate generator, but for now you can hard-wire it to construct the immediate for the <code class="language-plaintext highlighter-rouge">addi</code> instruction, without worrying about other immediate types.</p>

<p>To edit this subcircuit, edit the <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> file and not the <code class="language-plaintext highlighter-rouge">imm_gen</code> in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code class="language-plaintext highlighter-rouge">cpu.circ</code> to load the changes in your CPU.</p>

<p>Here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>inst</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">The instruction being executed</td>
    </tr>
    <tr>
      <td>ImmSel</td>
      <td>Input</td>
      <td>3</td>
      <td style="text-align: left">Value determining how to reconstruct the immediate</td>
    </tr>
    <tr>
      <td>imm</td>
      <td>Output</td>
      <td>32</td>
      <td style="text-align: left">Value of the immediate in the instruction</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-processor">Info: Processor</h3>

<p>We have provided a skeleton for your processor in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. You will be using your own implementations of the ALU and RegFile as you construct your datapath. You are responsible for constructing the entire datapath from scratch. For Part A, your completed processor should support the <code class="language-plaintext highlighter-rouge">addi</code> instruction using a two-stage pipeline, with IF in the first stage and ID, EX, MEM, and WB in the second stage. To start, however, we recommend you create a single-stage processor with no pipelining. Once that is working, you can modify your processor so that it has a 2-stage pipeline.</p>

<p>Your processor will get its program from the processor harness <code class="language-plaintext highlighter-rouge">run.circ</code>. Your processor will output the address of an instruction, and accept the instruction at that address as an input; essentially, it serves as instruction memory. We recommend that you take some time to inspect <code class="language-plaintext highlighter-rouge">run.circ</code> to see exactly what’s going on; this same harness will be used to test your final submission, so make sure your CPU fits in the harness before submitting your work! Your processor has 2 inputs that come from the harness:</p>

<table>
  <thead>
    <tr>
      <th>Input Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INSTRUCTION</td>
      <td>32</td>
      <td style="text-align: left">Driven with the instruction at the instruction memory address identified by the FETCH_ADDRESS (see below).</td>
    </tr>
    <tr>
      <td>CLOCK</td>
      <td>1</td>
      <td style="text-align: left">The input for the clock. As with the register file, this can be sent into subcircuits (e.g. the CLK input for your register file) or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not <code class="language-plaintext highlighter-rouge">AND</code> it with anything, etc.).</td>
    </tr>
  </tbody>
</table>

<p>Your processor must provide the following outputs to the harness:</p>

<table>
  <thead>
    <tr>
      <th>Output Name</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ra</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">ra</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>sp</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">sp</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>t0</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">t0</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>t1</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">t1</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>t2</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">t2</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>s0</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">s0</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>s1</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">s1</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>a0</td>
      <td>32</td>
      <td style="text-align: left">Driven with the contents of <code class="language-plaintext highlighter-rouge">a0</code> (FOR TESTING)</td>
    </tr>
    <tr>
      <td>fetch_addr</td>
      <td>32</td>
      <td style="text-align: left">This output is used to select which instruction is presented to the processor on the INSTRUCTION input.</td>
    </tr>
  </tbody>
</table>

<p>Just like with the ALU and RegFile, be careful <strong>NOT</strong> to move the input or output pins! See the “Testing” section for more information on the harness and tests.</p>

<hr />

<h3 id="info-control-logic">Info: Control Logic</h3>

<p>The Control Logic unit (<code class="language-plaintext highlighter-rouge">control_logic.circ</code>) provided in the skeleton is unimplemented. Designing your control logic unit will probably be your biggest challenge in Part B. For Part A, you can put a constant for each control signal, because <code class="language-plaintext highlighter-rouge">addi</code> is the only instruction you’ll be implementing. As you implement <code class="language-plaintext highlighter-rouge">addi</code>, think about where you’ll need to make additions in order to support other instructions.</p>

<p>To edit this subcircuit, edit the <code class="language-plaintext highlighter-rouge">control_logic.circ</code> file and not the <code class="language-plaintext highlighter-rouge">control_logic</code> in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code class="language-plaintext highlighter-rouge">cpu.circ</code> to load the changes in your CPU.</p>

<hr />

<h3 id="single-stage-cpu-a-guide">Single Stage CPU: A Guide</h3>

<p>We know that trying to build a CPU with a blank slate might be intimidating, so we wrote the following guide to help you.</p>

<p>Recall the five stages of the CPU pipeline:</p>

<ol>
  <li>Instruction Fetch (IF)</li>
  <li>Instruction Decode (ID)</li>
  <li>Execute (EX)</li>
  <li>Memory (MEM)</li>
  <li>Write Back (WB)</li>
</ol>

<p>This guide will help you work through each of these stages for the <code class="language-plaintext highlighter-rouge">addi</code> instruction. Each section will contain questions for you to think through and pointers to important details, but it won’t tell you exactly how to implement the instruction.</p>

<p>You may need to read and understand each question before going to the next one, and you can see the answers by <em>clicking on the question</em>. During your implementation, feel free to place things in subcircuits as you see fit.</p>

<h4 id="stage-1-instruction-fetch">Stage 1: Instruction Fetch</h4>

<p>The main thing we are concerned about in this stage is: how do we get the current instruction? From lecture, we know that instructions are stored in the instruction memory, and each of these instructions can be accessed through an address.</p>

<details>
  <summary>1. Which file in the project holds your instruction memory? How does it connect to your `cpu.circ` file?</summary>

  The instruction memory is the ROM module in `run.circ`. It provides an input into your CPU named `INSTRUCTION` and takes an output from your CPU. In your `cpu.circ` file, that output is called `PROGRAM_COUNTER`. In `run.circ`, it is called `fetch_addr`.
</details>

<details>
  <summary>2. In your CPU, how would changing the address you output as `PROGRAM_COUNTER` affect the instruction input?</summary>

  The instruction that `run.circ` outputs to your CPU should be the instruction at address `PROGRAM_COUNTER` (or `fetch_addr`) in instruction memory.
</details>

<details>
  <summary>3. How do you know what `PROGRAM_COUNTER` should be?</summary>

  `PROGRAM_COUNTER` is the address of the current instruction being executed, so it is saved in the PC register. For this project, your PC will start at 0, as that is the default value for a register.
</details>

<details>
  <summary>4. For basic programs without any jumps or branches, how will the PC change from line to line?</summary>

  The PC must increment by 1 instruction in order to go to the next instruction, as the address held by the PC register represents what instruction to execute. This means that your PC will typically increase by 4 (assuming no branch or jump) line to line.
</details>

<p><br /></p>

<p>In <code class="language-plaintext highlighter-rouge">cpu.circ</code>, we have provided a simple PC register implementation - ignoring jumps and branches. You will implement branches and jumps in Part 2 of the project, but for now we are only concerned with being able to run <code class="language-plaintext highlighter-rouge">addi</code> instructions.</p>

<p>Remember that we will in the end implement a 2-stage pipelined processor, so the IF stage is separate from the remaining stages. What circuitry separates the different stages of a pipeline? Specifically, what circuitry separates IF from the next stage? Will you need to add anything?</p>

<h4 id="stage-2-instruction-decode">Stage 2: Instruction Decode</h4>

<p>Now that we have our instruction coming from the <code class="language-plaintext highlighter-rouge">instruction</code> input, we break it down in the Instruction Decode step according to the RISC-V instruction formats you have learned.</p>

<details>
  <summary>1. What type of instruction is addi? What are the different bit fields and which bits are needed for each?</summary>

  I type. The fields are:
  - `imm [31-20]`
  - `rs1 [19-15]`
  - `funct3 [14-12]`
  - `rd [11-7]`
  - `opcode [6-0]`
</details>

<details>
  <summary>2. In Logisim, what tool would you use to **split** out different groups of bits?</summary>

  The Splitter!
</details>

<p>3. Implement the instruction field decode stage using the instruction input. You should use tunnels to label and group the bits.</p>

<details>
  <summary>4. Now we need to get the data from the corresponding registers, using the register file. Which instruction fields should be connected to the register file? Which inputs of the register file should it connect to?</summary>

  Instruction field `rs1` will need to connect to read register 1.
</details>

<p>5. Implement reading from the register file. You will have to bring in your RegFile from Part A. Remember to connect the clock!</p>

<details>
  <summary>6. What does the Immediate Generator need to do?</summary>

  For addi, the immediate generator takes in 12 bits from the instruction and produces a signed 32-bit immediate. You will need to implement this logic in the Immediate Generator subcircuit!
</details>

<h4 id="stage-3-execute">Stage 3: Execute</h4>

<p>The Execute stage is where the computation of most instructions is performed. This is also where we will introduce the idea of using a Control Module.</p>

<details>
  <summary>1. For the add instruction, what should be your inputs to the ALU?</summary>

  Read Data 1 (rs1) and the immediate produced by the Immediate Generator.
</details>

<details>
  <summary>2. In the ALU, what is the purpose of ALU_Sel?</summary>

  It determines which operation the ALU will perform.
</details>

<details>
  <summary>3. Although it is possible for now to just put a constant as the ALUSel, why would this be infeasible as you implement more instructions?</summary>

  With more instructions, the input to the ALU might need to change, so you will need to have some sort of circuit that changes ALUSel depending on the instruction being executed.
</details>

<p>4. Bring in your ALU and connect the ALU inputs correctly. Do you need to connect the clock? Why or why not?</p>

<p><br /></p>

<h4 id="stage-4-memory">Stage 4: Memory</h4>

<p>The memory stage is where the memory can be written to using store instructions and read from using load instructions. Because the <code class="language-plaintext highlighter-rouge">addi</code> instruction does not use memory, we will not spend too much time here.</p>

<p>Bring in the MEM module that we provided. At this point, we cannot connect most of the inputs, as we don’t know where they should come from. However, you can still connect the clock.</p>

<h4 id="stage-5-write-back">Stage 5: Write Back</h4>

<p>The write back stage is where the results of the operation is saved back to the registers.</p>

<details>
  <summary>1. Do `addi` instructions need to write back to a register?</summary>

  Yes. `addi` takes the output of a an addition computation in the ALU and writes it back to the register file.
</details>

<p>2. Let's create the write back phase so that it is able to write both ALU and MEM outputs to the Register File. Later, when you implement branching/jumping, you may need to add more to this mux. However, at the moment, we need to choose between the ALU and MEM outputs, as only one wire can end up being an input to the register file. Bring a wire from both the ALU and MEM, and connect it to a MUX.</p>

<details>
  <summary>3. What should you use as the Select input to the MUX? What does the input depend on?</summary>

  This input should be able to choose between three MUX inputs: (1) ALU, (2) MEM, and (3) PC + 4 (when will you use this?) The control signal that determines which of these inputs is written back is called WBSel. For now, there should only be one value that WBSel can take on -- whatever it should be for `addi`.
</details>

<details>
  <summary>4. Now that we have the inputs to the MUX sorted out, we need to wire the output. Where should the output connect to?</summary>

  Because the output is the data that you want to write into the Register File, it should connect to the Write Data input on the Register File.
</details>

<p>5. There are two more inputs on the Register File which are important for writing data: RegWEn and rd. One of these will come from the Instruction Decode stage and the other one will be a new control signal that you need to design for Part B. Please finish off the Writeback stage by these inputs on the RegFile correctly.</p>

<p>If you have done all of the steps correctly, you should have a single-cycle processor that works for <code class="language-plaintext highlighter-rouge">addi</code> instructions.</p>

<p>Run <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> and see if it’s working correctly!</p>

<hr />

<h3 id="pipelining-your-cpu">Pipelining Your CPU</h3>

<p>Now it’s time to implement pipelining in your CPU! For this project, you’ll need to implement a 2-stage pipeline, which is still conceptually similar to the 5-stage pipeline covered in lecture and discussion (review those if you haven’t already). The two stages you’ll implement are:</p>

<p><strong>1. Instruction Fetch:</strong> An instruction is fetched from the instruction memory.</p>

<p><strong>2. Execute:</strong> The instruction is decoded, executed, and committed (written back). This is a combination of the remaining four stages of a normal five-stage RISC-V pipeline (ID, EX, MEM and WB).</p>

<p>Because all of the control and execution is handled in the Execute stage, <strong>your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency.</strong> However, we will be enforcing the two-stage pipeline design. Some things to consider:</p>

<ul>
  <li>Will the IF and EX stages have the same or different <code class="language-plaintext highlighter-rouge">PC</code> values?</li>
  <li>Do you need to store the <code class="language-plaintext highlighter-rouge">PC</code> between the pipelining stages?</li>
</ul>

<p>You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won’t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a <code class="language-plaintext highlighter-rouge">nop</code>. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate <code class="language-plaintext highlighter-rouge">--&gt;</code> Reset Simulation (Cmd + R or Ctrl + R on Windows) to reset your processor.</p>

<p>After pipelining your processor, you should be able to pass <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_pipelined</code> test. Note that the single-stage test will now fail, which is expected behavior (why? look back at the reference outputs for each test, and think about the effects of pipelining on different stages).</p>

<hr />

<h3 id="testing">Testing</h3>

<h4 id="understanding-the-tests">Understanding the Tests</h4>

<p>Each test is a copy of the <code class="language-plaintext highlighter-rouge">run.circ</code> file included with the starter code that has instructions loaded into its IMEM. When you run logisim-evolution from the command line, the clock ticks, the program counter is incremented, and the values in each of the outputs is printed to stdout.</p>

<p>Let’s take as the one stage addi test as an example. It has 3 addi instructions (<code class="language-plaintext highlighter-rouge">addi t0, x0, 5</code>, <code class="language-plaintext highlighter-rouge">addi t1, t0, 7</code>, <code class="language-plaintext highlighter-rouge">addi s0, t0, 9</code>). Open <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/cpu-addi-pipelined.circ</code> in Logisim Evolution, and take a closer look at the various parts of the test file. At the top, you’ll see the place where your CPU is connected to the test outputs. With the starter code, you’ll see all xxxx’s, as you do below; when your CPU is working, this should not be the case. Your CPU takes in one input (instruction), and along with the values in each of the registers, it has one additional output: <code class="language-plaintext highlighter-rouge">fetch_addr</code>, or the address of the instruction to be fetched from IMEM to be executed the next clock cycle.</p>

<p>Be careful that you don’t move any of the inputs/outputs of your CPU around, or add any additional inputs/outputs. This will change the shape of the CPU subcircuit, and as a result the connections in the test files may no longer work properly.</p>

<p>Below the CPU, you’ll see instruction memory. The hex for the 3 addi instructions (0x00500293, 0x00728313, 0x00928413) has been loaded into instruction memory. Instruction memory takes in one input (called <code class="language-plaintext highlighter-rouge">fetch_addr</code>) and outputs the instruction at that address. <code class="language-plaintext highlighter-rouge">fetch_addr</code> is a 32-bit value, but because Logisim Evolution caps the size of ROM units at 2^16B, we have to use a splitter to get only 14 bits from <code class="language-plaintext highlighter-rouge">fetch_addr</code> (ignoring the bottommost two bits). Notice that <code class="language-plaintext highlighter-rouge">fetch_addr</code> is a <strong>byte address</strong>, not a word address.</p>

<p>So what happens when the clock ticks? Each tick of the clock increments an input in the test file called <code class="language-plaintext highlighter-rouge">Time_Step</code>. The clock will continue to tick until <code class="language-plaintext highlighter-rouge">Time_Step</code> is equal to the halting constant for that test file (for this particular test file, the halting constant is 5). At that point, the Logisim Evolution command line will print the values in each of your outputs to stdout. Our tests will compare this output to the expected; if your output is different, you will fail the test.</p>

<h4 id="addi-tests"><code class="language-plaintext highlighter-rouge">addi</code> Tests</h4>

<p>We’ve included 2 tests for the <code class="language-plaintext highlighter-rouge">addi</code> instruction with the starter code: one for a single-cycle CPU and one for a pipelined CPU. You can run the pipelined tests with the following commands (replace <code class="language-plaintext highlighter-rouge">pipelined</code> with <code class="language-plaintext highlighter-rouge">single</code> for single-cycle tests):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a addi_pipelined <span class="c"># For a pipelined CPU</span>
</code></pre></div></div>

<p>You can see the <code class="language-plaintext highlighter-rouge">.s</code> (RISC-V) and <code class="language-plaintext highlighter-rouge">.hex</code> (machine code) files for the test in <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/inputs</code>.</p>

<p>We’ve included a Python script to interpret your output: <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>, which works like <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> and <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> from the previous tasks. To use the script to see your CPU’s output, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out
</code></pre></div></div>

<p>or, to see the reference output, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out
</code></pre></div></div>

<hr />

<h2 id="part-a-submission">Part A: Submission</h2>

<p>At this point, if you’ve completed tasks 1-3, you’ve finished Part A of the project!</p>

<p>Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional <code class="language-plaintext highlighter-rouge">.circ</code> files; the autograder will only be testing the circuit files you needed to edit in the starter code (<code class="language-plaintext highlighter-rouge">alu.circ</code>, <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>, <code class="language-plaintext highlighter-rouge">control_logic.circ</code>, <code class="language-plaintext highlighter-rouge">cpu.circ</code>, <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>, and <code class="language-plaintext highlighter-rouge">regfile.circ</code>). Submit your repo to the <code class="language-plaintext highlighter-rouge">Project 3A</code> assignment on Gradescope.</p>

<p>The autograder for Part A uses the same tests as the test files provided in the starter code.</p>

<p>The rest of this spec describes the tasks for Part B.</p>

<hr />

<h2 id="part-b-getting-started">Part B: Getting Started</h2>

<p>We’ll still be using the same repository. Pull the starter code to get the files for Part B.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git pull starter master
</code></pre></div></div>

<hr />

<h2 id="task-4-more-instructions">Task 4: More Instructions</h2>

<p>In Task 3, you wired up a basic pipelined CPU capable of executing <code class="language-plaintext highlighter-rouge">addi</code> instructions. Now, you’ll implement support for more instructions!</p>

<h3 id="the-instruction-set-architecture-isa">The Instruction Set Architecture (ISA)</h3>

<p>We will be grading your CPU implementation on <strong>only</strong> the instructions listed below. Your CPU must support these instructions, but feel free to implement any additional instructions you want as long as they don’t affect your implementation of the required instructions. Implementing additional instructions will not affect your score.</p>

<table>
  <tr>
    <td><b>Instruction</b></td>
    <td><b>Type</b></td>
    <td><b>Opcode</b></td>
    <td><b>Funct3</b></td>
    <td><b>Funct7/Immediate</b></td>
    <td><b>Operation</b></td>
  </tr>
  <tr>
    <td>add rd, rs1, rs2</td>
    <td rowspan="14">R</td>
    <td rowspan="14">0x33</td>
    <td>0x0</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] + R[rs2]</td>
  </tr>
  <tr>
    <td>mul rd, rs1, rs2</td>
    <td>0x0</td>
    <td>0x01</td>
    <td>R[rd] &larr; (R[rs1] * R[rs2])[31:0]</td>
  </tr>
  <tr>
    <td>sub rd, rs1, rs2</td>
    <td>0x0</td>
    <td>0x20</td>
    <td>R[rd] &larr; R[rs1] - R[rs2]</td>
  </tr>
  <tr>
    <td>sll rd, rs1, rs2</td>
    <td>0x1</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] &lt;&lt; R[rs2]</td>
  </tr>
  <tr>
    <td>mulh rd, rs1, rs2</td>
    <td>0x1</td>
    <td>0x01</td>
    <td>R[rd] &larr; (R[rs1] * R [rs2])[63:32]</td>
  </tr>
  <tr>
    <td>mulhu rd, rs1, rs2</td>
    <td>0x3</td>
    <td>0x01</td>
    <td>(unsigned) R[rd] &larr; (R[rs1] * R[rs2])[63:32]</td>
  </tr>
  <tr>
    <td>slt rd, rs1, rs2</td>
    <td>0x2</td>
    <td>0x00</td>
    <td>R[rd] &larr; (R[rs1] &lt; R[rs2]) ? 1 : 0 (signed)</td>
  </tr>
  <tr>
    <td>xor rd, rs1, rs2</td>
    <td>0x4</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] ^ R[rs2]</td>
  </tr>
  <tr>
    <td>divu rd, rs1, rs2</td>
    <td>0x5</td>
    <td>0x01</td>
    <td>(unsigned) R[rd] &larr; R[rs1] / R[rs2]</td>
  </tr>
  <tr>
    <td>srl rd, rs1, rs2</td>
    <td>0x5</td>
    <td>0x00</td>
    <td>(unsigned) R[rd] &larr; R[rs1] &gt;&gt; R[rs2]</td>
  </tr>
 <tr>
    <td>sra rd, rs1, rs2</td>
    <td>0x5</td>
    <td>0x20</td>
    <td>(signed) R[rd] &larr; R[rs1] &gt;&gt; R[rs2]</td>
  </tr>
  <tr>
    <td>or rd, rs1, rs2</td>
    <td>0x6</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] | R[rs2]</td>
  </tr>
  <tr>
    <td>remu rd, rs1, rs2</td>
    <td>0x7</td>
    <td>0x01</td>
    <td>(unsigned) R[rd] &larr; R[rs1] % R[rs2]</td>
  </tr>
  <tr>
    <td>and rd, rs1, rs2</td>
    <td>0x7</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] &amp; R[rs2]</td>
  </tr>
  <tr>
    <td>lb rd, offset(rs1)</td>
    <td rowspan="11">I</td>
    <td rowspan="3">0x03</td>
    <td>0x0</td>
    <td></td>
    <td>R[rd] &larr; SignExt(Mem(R[rs1] + offset, byte))</td>
  </tr>
  <tr>
    <td>lh rd, offset(rs1)</td>
    <td>0x1</td>
    <td></td>
    <td>R[rd] &larr; SignExt(Mem(R[rs1] + offset, half))</td>
  </tr>
  <tr>
    <td>lw rd, offset(rs1)</td>
    <td>0x2</td>
    <td></td>
    <td>R[rd] &larr; Mem(R[rs1] + offset, word)</td>
  </tr>
  <tr>
    <td>addi rd, rs1, imm</td>
    <td rowspan="8">0x13</td>
    <td>0x0</td>
    <td></td>
    <td>R[rd] &larr; R[rs1] + imm</td>
  </tr>
  <tr>
    <td>slli rd, rs1, imm</td>
    <td>0x1</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] &lt;&lt; imm</td>
  </tr>
  <tr>
    <td>slti rd, rs1, imm</td>
    <td>0x2</td>
    <td></td>
    <td>R[rd] &larr; (R[rs1] &lt; imm) ? 1 : 0</td>
  </tr>
  <tr>
    <td>xori rd, rs1, imm</td>
    <td>0x4</td>
    <td></td>
    <td>R[rd] &larr; R[rs1] ^ imm</td>
  </tr>
  <tr>
    <td>srli rd, rs1, imm</td>
    <td>0x5</td>
    <td>0x00</td>
    <td>R[rd] &larr; R[rs1] &gt;&gt; imm</td>
  </tr>
  <tr>
     <td>srai rd, rs1, imm</td>
    <td>0x5</td>
    <td>0x20</td>
    <td>R[rd] &larr; R[rs1] &gt;&gt; imm</td>
  </tr>
  <tr>
    <td>ori rd, rs1, imm</td>
    <td>0x6</td>
    <td></td>
    <td>R[rd] &larr; R[rs1] | imm</td>
  </tr>
  <tr>
    <td>andi rd, rs1, imm</td>
    <td>0x7</td>
    <td></td>
    <td>R[rd] &larr; R[rs1] &amp; imm</td>
  </tr>
  <tr>
    <td>sw rs2, offset(rs1)</td>
    <td rowspan="2">S</td>
    <td rowspan="2">0x23</td>
    <td>0x2</td>
    <td></td>
    <td>Mem(R[rs1] + offset) &larr; R[rs2]</td>
  </tr>
  <tr>
    <td>swlt rs2, offset(rs1)</td>
    <td>0x7</td>
    <td></td>
    <td class="c8">
    if(R[rs2] &lt; offset (signed))
        <br />
        &nbsp;Mem(R[rs1]) &larr; R[rs2]</td>
  </tr>
  <tr>
    <td>beq rs1, rs2, offset</td>
    <td rowspan="6">SB</td>
    <td rowspan="6">0x63</td>
    <td>0x0</td>
    <td></td>
    <td class="c8">
      if(R[rs1] == R[rs2])
      <br />
      &nbsp;PC &larr; PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>bne rs1, rs2, offset</td>
    <td>0x1</td>
    <td></td>
    <td class="c8">
      if(R[rs1] != R[rs2])
      <br />
      &nbsp;PC &larr;  PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>blt rs1, rs2, offset</td>
    <td>0x4</td>
    <td></td>
    <td class="c8">
      if(R[rs1] &lt;  R[rs2] (signed))
      <br />
      &nbsp;PC &larr; PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>bge rs1, rs2, offset</td>
    <td>0x5</td>
    <td></td>
    <td class="c8">
      if(R[rs1] &gt;=  R[rs2] (signed))
      <br />
      &nbsp;PC &larr; PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>bltu rs1, rs2, offset</td>
    <td>0x6</td>
    <td></td>
    <td class="c8">
      if(R[rs1] &lt;  R[rs2] (unsigned))
      <br />
      &nbsp;PC &larr; PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>bgeu rs1, rs2, offset</td>
    <td>0x7</td>
    <td></td>
    <td class="c8">
      if(R[rs1] &gt;=  R[rs2] (unsigned))
      <br />
      &nbsp;PC &larr; PC + {offset, 1b0}
    </td>
  </tr>
  <tr>
    <td>auipc rd, offset</td>
    <td rowspan="2">U</td>
    <td>0x17</td>
    <td></td>
    <td></td>
    <td>R[rd] &larr; PC + {offset, 12b0}</td>
  </tr>
  <tr>
    <td>lui rd, offset</td>
    <td>0x37</td>
    <td></td>
    <td></td>
    <td>R[rd] &larr; {offset, 12b0}</td>
  </tr>
  <tr>
    <td>jal rd, imm</td>
    <td>UJ</td>
    <td>0x6f</td>
    <td></td>
    <td></td>
    <td class="c8">
      R[rd] &larr; PC  +  4
      <br />
      &nbsp;PC &larr; PC + {imm, 1b0}
    </td>
  </tr>
  <tr>
    <td>jalr rd, rs1, imm</td>
    <td>I</td>
    <td>0x67</td>
    <td>0x0</td>
    <td></td>
    <td class="c8">
      R[rd] &larr; PC  +  4
      <br />
      &nbsp;PC &larr; R[rs1] + {imm}
    </td>
  </tr>
</table>

<hr />

<h3 id="info-memory-1">Info: Memory</h3>

<p>The Memory unit (located in <code class="language-plaintext highlighter-rouge">mem.circ</code>) is already fully implemented for you! You may use this circuit in your CPU, but the autograder will not accept any modifications to <code class="language-plaintext highlighter-rouge">mem.circ</code>.</p>

<p>Note that the address you give to memory is a byte address, but memory returns an entire word of memory. The memory unit ignores the bottom two bits of the address you provide to it, and treats its input as a <strong>word address</strong> rather than a <strong>byte address</strong>. For example, if you input the 32-bit address 0x0000_1007, it wil be treated as the word address 0x0000_1004, and you will get as output the 4 bytes at addresses 0x0000_1004, 0x0000_1005, 0x0000_1006, and 0x0000_1007.</p>

<p>Note that for the <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, and <code class="language-plaintext highlighter-rouge">sw</code> instructions, the RISC-V ISA supports unaligned accesses, but implementing them is complicated. We’ll only be implementing <em>aligned</em> memory accesses in this project. This means that <code class="language-plaintext highlighter-rouge">lw</code> and <code class="language-plaintext highlighter-rouge">sw</code> will only operate on addresses that are multiples of 4, and <code class="language-plaintext highlighter-rouge">lh</code> will only operate on addresses that are multiples of 2. You <strong>must not</strong> implement unaligned accesses; you would likely need to use stalling, which would result in your output not matching our expected output (bad for your score).</p>

<p>Again, here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WriteAdd</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Address to read/write to in Memory</td>
    </tr>
    <tr>
      <td>WriteData</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value to be written to Memory</td>
    </tr>
    <tr>
      <td>MemRW</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Equal to one on any instructions that write to Memory and zero otherwise</td>
    </tr>
    <tr>
      <td>CLK</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Driven by the clock input to the CPU</td>
    </tr>
    <tr>
      <td>ReadData</td>
      <td>Output</td>
      <td>32</td>
      <td style="text-align: left">Value of the data stored at the specified address</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-branch-comparator-1">Info: Branch Comparator</h3>

<p>The Branch Comparator unit (located in <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>) compares two values and outputs control signals that will be used to make branching decisions. You will need to implement logic for this circuit.</p>

<p>To edit this subcircuit, edit the <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> file and not the <code class="language-plaintext highlighter-rouge">branch_comp</code> in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code class="language-plaintext highlighter-rouge">cpu.circ</code> to load the changes in your CPU.</p>

<p>Again, here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rs1</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value in the first register to be compared</td>
    </tr>
    <tr>
      <td>rs2</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">Value in the second register to be compared</td>
    </tr>
    <tr>
      <td>BrUn</td>
      <td>Input</td>
      <td>1</td>
      <td style="text-align: left">Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted</td>
    </tr>
    <tr>
      <td>BrEq</td>
      <td>Output</td>
      <td>1</td>
      <td style="text-align: left">Equal to one if the two values are equal</td>
    </tr>
    <tr>
      <td>BrLt</td>
      <td>Output</td>
      <td>1</td>
      <td style="text-align: left">Equal to one if the value in rs1 is less than the value in rs2</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-immediate-generator-1">Info: Immediate Generator</h3>

<p>The Immediate Generator (“Imm Gen”) unit (located in <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) extracts the appropriate immediate from <code class="language-plaintext highlighter-rouge">I</code>, <code class="language-plaintext highlighter-rouge">S</code>, <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">U</code>, and <code class="language-plaintext highlighter-rouge">J</code> type instructions. Remember that in RISC-V, all immediates that leave the immediate generator are 32-bits and sign-extended! See the table below for how each immediate should be formatted:</p>

<p><img src="immediates.png" alt="alt-text" /></p>

<p>To edit this subcircuit, edit the <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> file and not the <code class="language-plaintext highlighter-rouge">imm_gen</code> in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code class="language-plaintext highlighter-rouge">cpu.circ</code> to load the changes in your CPU.</p>

<p>Again, here’s a quick summary of its inputs and outputs:</p>

<table>
  <thead>
    <tr>
      <th>Signal Name</th>
      <th>Direction</th>
      <th>Bit Width</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>inst</td>
      <td>Input</td>
      <td>32</td>
      <td style="text-align: left">The instruction being executed</td>
    </tr>
    <tr>
      <td>ImmSel</td>
      <td>Input</td>
      <td>3</td>
      <td style="text-align: left">Value determining how to reconstruct the immediate</td>
    </tr>
    <tr>
      <td>imm</td>
      <td>Output</td>
      <td>32</td>
      <td style="text-align: left">Value of the immediate in the instruction</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="info-control-logic-1">Info: Control Logic</h3>

<p>The Control Logic unit (<code class="language-plaintext highlighter-rouge">control_logic.circ</code>) provided in the skeleton is based on the control logic unit in the 5-stage CPU used in lecture and discussion. In order to correctly identify each instruction, control signals play a very important part in this project. However, figuring out all of the control signals may seem intimidating. We suggest taking a look at the lecture slides and discussion worksheets to get started. Try walking through the datapath with different types of instructions; when you see a MUX or other component, think about what selector/enable value you will need for that instruction.</p>

<p>There are a two major approaches to implementing the control logic so that it can extract the <code class="language-plaintext highlighter-rouge">opcode</code>/<code class="language-plaintext highlighter-rouge">funct3</code>/<code class="language-plaintext highlighter-rouge">funct7</code> from an instruction and set the control signals appropriately.</p>

<p>The recommended method is <strong>hard-wired control</strong>, as discussed in lecture, which is usually the preferred approach for RISC architectures like MIPS and RISC-V. Hard-wired control uses “AND”, “OR”, and “NOT” gates (along with the various components we’ve learned can be built from these gates, like MUXes and DEMUXes) to produce the appropriate control signals. An <strong>instruction decoder</strong> takes in an instruction and outputs all of the control signals for that instruction.</p>

<p>The other way to do it is to use <strong>ROM control</strong>. Every instruction implemented by a processor maps to an address in a Read-Only Memory (ROM) unit. At that address in the ROM is the control word for that instruction. An <strong>address decoder</strong> takes in an instruction and outputs the address of the control word for that instruction. This approach is common in CISC architectures like Intel’s x86-64, and, in real life, offers some flexibility because it can be re-programmed by changing the contents of the ROM.</p>

<p>To edit this subcircuit, edit the <code class="language-plaintext highlighter-rouge">control_logic.circ</code> file and not the <code class="language-plaintext highlighter-rouge">control_logic</code> in <code class="language-plaintext highlighter-rouge">cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code class="language-plaintext highlighter-rouge">cpu.circ</code> to load the changes in your CPU.</p>

<hr />

<h3 id="info-processor-1">Info: Processor</h3>

<p>The main CPU circuit (located in <code class="language-plaintext highlighter-rouge">cpu.circ</code>) implements the main datapath and connects all the subcircuits (ALU, Branch Comparator, Control Logic, Immediate Generator, Memory, and RegFile) together. In Part A, you implemented a simple two-stage pipeline in your CPU. Since Part B requires support for branch and jump instructions, you’ll need to handle control hazards that occur when branching.</p>

<p>The instruction immediately after a branch or jump is not executed if a branch is taken. This makes your task a bit more complex. By the time you have figured out that a branch or jump is in the execute stage, you have already accessed the instruction memory and pulled out (possibly) the wrong instruction. You will therefore need to “kill” instruction that is being fetched if the instruction under execution is a jump or a taken branch.</p>

<p>Instruction kills for this project MUST be accomplished by MUXing a <code class="language-plaintext highlighter-rouge">nop</code> into the instruction stream and sending the <code class="language-plaintext highlighter-rouge">nop</code> into the Execute stage instead of using the fetched instruction. Notice that 0x00000013, or <code class="language-plaintext highlighter-rouge">addi x0, x0, 0</code> is a <code class="language-plaintext highlighter-rouge">nop</code> instruction; other <code class="language-plaintext highlighter-rouge">nop</code> instructions will work too. You should only kill if a branch is taken (do not kill otherwise). Do kill on every type of jump.</p>

<p>Do not solve this issue by calculating branch offsets in the IF stage. If we test your output against the reference every cycle, and the reference returns a <code class="language-plaintext highlighter-rouge">nop</code>, while it may be a conceptually correct solution, this will cause you to fail our tests.</p>

<p>Because all of the control and execution is handled in the Execute stage, <strong>your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency and the branch/jump delays.</strong> However, we will be enforcing the two-stage pipeline design. Some things to consider:</p>

<ul>
  <li>Will the IF and EX stages have the same or different <code class="language-plaintext highlighter-rouge">PC</code> values?</li>
  <li>Do you need to store the <code class="language-plaintext highlighter-rouge">PC</code> between the pipelining stages?</li>
  <li>To MUX a <code class="language-plaintext highlighter-rouge">nop</code> into the instruction stream, do you place it <em>before</em> or <em>after</em> the instruction register?</li>
  <li>What address should be requested next while the EX stage executes a <code class="language-plaintext highlighter-rouge">nop</code>?  Is this different than normal?</li>
</ul>

<p>You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won’t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a <code class="language-plaintext highlighter-rouge">nop</code>. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate <code class="language-plaintext highlighter-rouge">--&gt;</code> Reset Simulation (Ctrl+R) to reset your processor.</p>

<hr />

<h3 id="cpu-testing-pipelined-sanity-tests">CPU Testing: Pipelined Sanity Tests</h3>

<p>We’ve provided a group of basic sanity tests for your pipelined CPU in <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_b pipelined
</code></pre></div></div>

<p>You can see the <code class="language-plaintext highlighter-rouge">.s</code> (RISC-V) and <code class="language-plaintext highlighter-rouge">.hex</code> (machine code) files for the test in <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined/inputs</code>.</p>

<p>We’ve also provided <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>, which works like <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code> from Task 3.</p>

<hr />

<h2 id="task-5-custom-tests">Task 5: Custom Tests</h2>

<p>The autograder tests fall into 3 main categories: <strong>unit tests</strong>, <strong>integration tests</strong>, and <strong>edge case tests</strong>. For Part B, we won’t be revealing all the autograder tests, but you should be able to re-create a very close approximation of them on your own in order to test your CPU.</p>

<p><strong>Unit tests</strong>: a unit test exercises your datapath with a single instruction, to make sure that each individual instruction has been implemented and is working as expected. You should write a different unit test for every single instruction that you need to implement, and make sure that you test the spectrum of possibilities for that instruction thoroughly. For example, a unit test <code class="language-plaintext highlighter-rouge">slt</code> should contain cases where <code class="language-plaintext highlighter-rouge">rs1 &lt; rs2</code>, <code class="language-plaintext highlighter-rouge">rs1 &gt; rs2</code>, and where <code class="language-plaintext highlighter-rouge">rs1 == rs2</code>.</p>

<p><strong>Integration tests</strong>: After you’ve passed your unit tests, move onto tests that use multiple functions in combination. Try out various simple RISC-V programs that run a single function; your CPU should be able to handle them, if working properly. Feel free to try to use riscv-gcc to compile C programs to RISC-V, but be aware of the limited instruction set we’re working with (you don’t have any <code class="language-plaintext highlighter-rouge">ecall</code> instructions, for example). We’d recommend that you instead try to write simple functions on your own based on what you’ve seen in labs, discussions, projects, and exams.</p>

<p><strong>Edge case tests</strong>: edge case tests try inputs that you normally wouldn’t expect, which may trigger bugs in certain situations. What edge cases should you look for? A small hint from us: our 2 main classes of edge cases come from memory operations and branch/jump operations (some of the test names are “mem-full” and “br-jump-edge”). Think about all the different ways these operations could go wrong.</p>

<h3 id="creating-custom-tests">Creating Custom Tests</h3>

<p>We’ve included a script (<code class="language-plaintext highlighter-rouge">create-test.py</code>) that uses Venus to help you generate test circuits from RISC-V assembly! The process for generating a custom test is as follows:</p>

<ol>
  <li>Come up the RISC-V assembly instructions for the test, and save them in a file ending in <code class="language-plaintext highlighter-rouge">.s</code> in the <code class="language-plaintext highlighter-rouge">tests/part_b/custom/inputs</code> folder. The name of this file will be the name of your test. Note that your test <strong>must</strong> end in <code class="language-plaintext highlighter-rouge">.s</code>, and it <strong>must</strong> be located in the <code class="language-plaintext highlighter-rouge">tests/part_b/custom/inputs</code> folder. Repeat if you have more tests.
    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge">tests/part_b/custom/inputs/sll-slli.s</code>, <code class="language-plaintext highlighter-rouge">tests/part_b/custom/inputs/slt.s</code></li>
    </ul>
  </li>
  <li>Repeat step 1 if you have more tests.</li>
  <li>To generate test circuits for your tests, run the <code class="language-plaintext highlighter-rouge">create-test.py</code> script:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_b/custom
<span class="nv">$ </span>python3 create-test.py inputs/sll-slli.s inputs/slt.s
</code></pre></div>    </div>
    <p>This should generate a couple new files:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tests/part_b/custom:
  - &lt;TEST_NAME&gt;.circ # The new circuit for your test
  - inputs/&lt;TEST_NAME&gt;.s # The test file you wrote
  - inputs/&lt;TEST_NAME&gt;.hex # The machine code of the test file you wrote
  - reference_outputs/&lt;TEST_NAME&gt;-ref.out # The reference output for your test
</code></pre></div>    </div>
  </li>
  <li>Now you can run your tests!
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_b custom
</code></pre></div>    </div>
  </li>
</ol>

<p>If you want to inspect the circuit running your test, you can simulate it by opening up the <code class="language-plaintext highlighter-rouge">CPU-&lt;test name here&gt;.circ</code> file, right-clicking on the CPU, selecting ‘view main’, and using Cmd + T (Ctrl + T on Windows) to manually tick the clock through each cycle. If you don’t remember how to simulate your circuit, please refer back to the Logisim lab. We highly encourage you to poke your circuit while simulating the test to observe how your circuit reacts to various inputs (perhaps this can give you ideas for new tests to write).</p>

<p>If you wish to simulate your code only for a certain number of cycles, you can do that by using the <code class="language-plaintext highlighter-rouge">-n</code> flag:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 create_test.py <span class="nt">-n</span> &lt;NUMBER_OF_CYCLES&gt; &lt;TEST_NAME&gt;.s
</code></pre></div></div>

<p>If you would like to decode your output, use the provided <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>. Note that because you’re implementing a 2-stage pipelined processor and the first instruction writes on the rising edge of the second clock cycle, the effects of your instructions will have a 2 instruction delay. For example, let’s say you wrote a test with one instruction: <code class="language-plaintext highlighter-rouge">addi t0, x0, 1</code>. If you inspect the reference output, you’ll see that <code class="language-plaintext highlighter-rouge">t0</code> isn’t changed until the third cycle.</p>

<hr />

<h3 id="using-web-venus">Using Web Venus</h3>

<p>Although we have specified three custom additional instructions, Venus does not support them because they are not standard or standard extension instructions. Because of this, one of your instructor’s Stephan (the person maintaining Venus), made a package system with which you can make custom packages for Venus. There is a package which will add the <em>swlt</em> instructions to Venus so that you can properly test these custom instructions with the web version of Venus!</p>

<p>Here is how you would go about doing this: Either</p>

<ol>
  <li>
    <p>Click on this link which should auto add the package (<a href="https://venus.cs61c.org?packages=https://cs61c.org/su20/projects/proj3/proj3_2-venus_package.js">https://venus.cs61c.org?packages=https://cs61c.org/su20/projects/proj3/proj3_2-venus_package.js</a>)</p>
  </li>
  <li>
    <p>OR Go to <a href="https://venus.cs61c.org?packages=https://cs61c.org/su20/projects/proj3/proj3_2-venus_package.js">https://venus.cs61c.org</a>. Click on the Venus tab at the top (it is the left most one). Now look for the settings section (it should be on the right if your screen is large enough otherwise you will have to scroll down to see it). From there you should click on the Packages word to see the packages which you can enable/disable or add or remove. Next paste this link (https://cs61c.org/su20/projects/proj3/proj3_2-venus_package.js) in the box and then click add package. You should see a message saying <code class="language-plaintext highlighter-rouge">Loaded script (https://cs61c.org/su20/projects/proj3/proj3_2-venus_package.js)!</code></p>
  </li>
</ol>

<p>Now you can actually use the custom instructions in the web version of Venus just as if they were normal instructions!</p>

<h3 id="test-coverage">Test Coverage</h3>

<p><strong>Test coverage</strong>: a metric measuring how much of a given codebase is being tested by tests. For the purposes of this project, you will be graded on how much of the required ISA your tests cover.</p>

<p>The autograder for Part B will examine the coverage of tests located in the <code class="language-plaintext highlighter-rouge">tests/part_b/custom/inputs</code> folder. When you submit Part B to the autograder. The autograder will output a message about the percentage coverage of your tests against our staff suite of tests, and notify you if any of your tests raised a syntax error.</p>

<p>Hints:</p>

<ul>
  <li>If you make many short test files rather than one large one, it will be easier to figure out which test and which line causes your Syntax Error (and to figure out where your CPU is failing). We’d recommend that for unit testing, where you have one .s file testing each instruction.</li>
  <li>Make sure you test every single instruction in the ISA, including the ones that are covered by the sanity tests; feel free to use the sanity tests as a model or even incorporate them as part of your test suite.</li>
  <li>Make sure you check that all registers are working.</li>
  <li>Make sure you don’t have any “dummy” tests; if a test doesn’t lead to a change in state or register value, it is not a meaningful test.</li>
  <li>Use only the registers we told you to implement: <code class="language-plaintext highlighter-rouge">x0</code>, <code class="language-plaintext highlighter-rouge">ra</code>, <code class="language-plaintext highlighter-rouge">sp</code>, <code class="language-plaintext highlighter-rouge">t0</code>, <code class="language-plaintext highlighter-rouge">t1</code>, <code class="language-plaintext highlighter-rouge">t2</code>, <code class="language-plaintext highlighter-rouge">s0</code>, <code class="language-plaintext highlighter-rouge">s1</code>, and <code class="language-plaintext highlighter-rouge">a0</code>.</li>
</ul>

<hr />

<h2 id="part-b-submission">Part B: Submission</h2>

<p>At this point, if you’ve completed tasks 4-5, you’ve finished Part B of the project. Congratulations on your shiny new CPU!</p>

<p><strong>Your final task before you submit is to write down how you implemented your CPU inside the readme.md. There is already a template for you to use and don’t worry about going into too much detail, we just want you to reflect on what you did in this project and explain the reasoning behind the design choices you made (especially in your control logic)!</strong></p>

<p>Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional <code class="language-plaintext highlighter-rouge">.circ</code> files; the autograder will only be testing the circuit files you needed to edit in the starter code (<code class="language-plaintext highlighter-rouge">branch_comp.circ</code>, <code class="language-plaintext highlighter-rouge">control_logic.circ</code>, <code class="language-plaintext highlighter-rouge">cpu.circ</code>, <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>). Also make sure your custom <code class="language-plaintext highlighter-rouge">.s</code> tests are located in the right folder. The autograder will be released soon; please be patient!</p>

<p>The autograder for Part B uses the sanity tests provided in the starter code, as well as hidden unit, integration, and edge case tests as specified in Task 5. Additionally, the autograder will be checking your custom tests for test coverage. The autograder will use the staff solution for <code class="language-plaintext highlighter-rouge">alu.circ</code> and <code class="language-plaintext highlighter-rouge">regfile.circ</code>, so if those are incomplete from Part A they will not affect your grade for Part B.</p>

<hr />

<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>

<ul>
  <li><strong>Q</strong>: I have pipelined my CPU, but the autograder said it detected a single-cycle one, what is the problem?<br />
  <strong>A</strong>: If you’re certain that you correctly pipelined, then it means that Logisim crashed when attempting to open your circuit. Generally this is caused by import issues, meaning you used a circuit that isn’t in the correct place. Remember that you shouldn’t be creating any new circ files and your ALU and RegFile files will be replaced with the staff solution, so don’t use any subcircuits you created in those files in your CPU.<br /><br /></li>
  <li><strong>Q</strong>: I want to add more inputs and outputs to one of my circuits. Is this allowed?<br />
<strong>A</strong>: This is allowed, however beware of messing up your circuit appearance. This can cause pins to move to the wrong place and make you fail all the sanity tests. You can check you circuit appearance by right-clicking on your circuit and selecting “Edit Circuit Appearance” to move the new pins around if necessary, though this is not recommended. <strong>WARNING: If you fail autograder tests because of added inputs/outputs we will not allow you to fix and resubmit after the deadline.</strong> If you want to add extra logic or controls to your CPU (for swlt for example) we recommend making a control subcircuit in cpu.circ.<br /><br /></li>
  <li><strong>Q</strong>: Are we allowed to use all the Logisim main library blocks? Where can I find information on them?<br />
  <strong>A</strong>: Yes, you can use any blocks that you can find in Logisim’s main library. You can find information on these blocks by going to Help-&gt;Library Reference.<br /></li>
</ul>

<hr />

<h2 id="grading">Grading</h2>

<p>The grading breakdown for Project 3 is as follows:</p>

<ul>
  <li>Part A (20%, 23% with extra credit)
    <ul>
      <li>ALU (8%, 11% with <code class="language-plaintext highlighter-rouge">mulh</code> extra credit)</li>
      <li>RegFile (8%)</li>
      <li>Pipelined <code class="language-plaintext highlighter-rouge">addi</code> (4%)</li>
    </ul>
  </li>
  <li>Part B (80%)
    <ul>
      <li>Sanity Tests (15%)</li>
      <li>Test Coverage (10%)</li>
      <li>Hidden Unit, Integration, and Edge Case Tests (55%)</li>
    </ul>
  </li>
</ul>

        </div>
        <div class="col-sm-3">
            <nav id="toc" class="sticky-top" style="top: 40px;"></nav>
        </div>
    </div>
    
    <script>
        $(function() {
            var navSelector = "#toc";
            var $myNav = $(navSelector);
            Toc.init($myNav);
            $("body").scrollspy({
                target: navSelector
            });
        });
    </script>


          </div>
    </div>

    <footer class="page-footer">
        <ul class="nav justify-content-center">
            <li class="nav-item">
                <a class="nav-link text-secondary" href="https://cs61c.org/su20">
                  CS 61C
                </a>
              </li>
            
            
              

<li class="nav-item">
    <a class="nav-link "  href="../../calendar.html" >
      Calendar
    </a>
  </li>

            
              

<li class="nav-item">
    <a class="nav-link "  href="../../staff.html" >
      Staff
    </a>
  </li>

            
              

<li class="nav-item">
    <a class="nav-link "  href="../../policies.html" >
      Policies
    </a>
  </li>

            
              

<li class="nav-item">
    <a class="nav-link  text-dark "  href="https://piazza.com/" >
      Piazza
    </a>
  </li>

            
            
              

<li class="nav-item">
    <a class="nav-link  text-dark "  href="https://venus.cs61c.org/" >
      Venus
    </a>
  </li>

            
              

<li class="nav-item">
    <a class="nav-link "  href="https://cs61c.org/resources/" >
      Resources
    </a>
  </li>

            
              

<li class="nav-item">
    <a class="nav-link "  href="https://cs61c.org/?redirect=false" >
      Semesters
    </a>
  </li>

            

            <li class="nav-item">
              <a class="nav-link text-secondary" href="index.html#">
                Back to top
              </a>
            </li>
        </ul>
    </footer>

    <script type="text/javascript" src="../../../assets/theme/theme.js"></script>
  </body>
</html>
